<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>helper.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav class="wrap">
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module-api-FormUrlEncoded.html">FormUrlEncoded</a><ul class='methods'><li data-type='method'><a href="module-api-FormUrlEncoded.html#set">set</a></li><li data-type='method'><a href="module-api-FormUrlEncoded.html#append">append</a></li><li data-type='method'><a href="module-api-FormUrlEncoded.html#delete">delete</a></li><li data-type='method'><a href="module-api-FormUrlEncoded.html#str">str</a></li><li data-type='method'><a href="module-api-FormUrlEncoded.html#url">url</a></li></ul></li><li><a href="module-api-TeraBoxApp.html">TeraBoxApp</a><ul class='methods'><li data-type='method'><a href="module-api-TeraBoxApp.html#updateAppData">updateAppData</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#setVipDefaults">setVipDefaults</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#doReq">doReq</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getSysCfg">getSysCfg</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#checkLogin">checkLogin</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#passportPreLogin">passportPreLogin</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#passportLogin">passportLogin</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#regSendCode">regSendCode</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#regVerify">regVerify</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#regFinish">regFinish</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#passportGetInfo">passportGetInfo</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#userMembership">userMembership</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getCurrentUserInfo">getCurrentUserInfo</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getUserInfo">getUserInfo</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getQuota">getQuota</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getCoinsCount">getCoinsCount</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getRemoteDir">getRemoteDir</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getCategoryList">getCategoryList</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getRecycleBin">getRecycleBin</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#clearRecycleBin">clearRecycleBin</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#precreateFile">precreateFile</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#rapidUpload">rapidUpload</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#remoteUpload">remoteUpload</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getUploadHost">getUploadHost</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#uploadChunk">uploadChunk</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#createDir">createDir</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#createFile">createFile</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#filemanager">filemanager</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#shareList">shareList</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#shareSet">shareSet</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#shareCancel">shareCancel</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#shortUrlInfo">shortUrlInfo</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#shortUrlList">shortUrlList</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#fileDiff">fileDiff</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#genPanToken">genPanToken</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getHomeInfo">getHomeInfo</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#download">download</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getStream">getStream</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getFileMeta">getFileMeta</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getRecentUploads">getRecentUploads</a></li><li data-type='method'><a href="module-api-TeraBoxApp.html#getPublicKey">getPublicKey</a></li></ul></li></ul><h3>Modules</h3><ul><li><a href="module-api.html">api</a><ul class='methods'><li data-type='method'><a href="module-api.html#~signDownload">signDownload</a></li><li data-type='method'><a href="module-api.html#~checkMd5val">checkMd5val</a></li><li data-type='method'><a href="module-api.html#~checkMd5arr">checkMd5arr</a></li><li data-type='method'><a href="module-api.html#~decodeMd5">decodeMd5</a></li><li data-type='method'><a href="module-api.html#~changeBase64Type">changeBase64Type</a></li><li data-type='method'><a href="module-api.html#~decryptAES">decryptAES</a></li><li data-type='method'><a href="module-api.html#~encryptRSA">encryptRSA</a></li><li data-type='method'><a href="module-api.html#~prandGen">prandGen</a></li></ul></li><li><a href="module-helper.html">helper</a><ul class='methods'><li data-type='method'><a href="module-helper.html#~getChunkSize">getChunkSize</a></li><li data-type='method'><a href="module-helper.html#~hashFile">hashFile</a></li><li data-type='method'><a href="module-helper.html#~uploadChunks">uploadChunks</a></li><li data-type='method'><a href="module-helper.html#~unwrapErrorMessage">unwrapErrorMessage</a></li></ul></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">helper.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import fs from 'node:fs';
import path from 'node:path';
import crypto from 'node:crypto';
import readline from 'node:readline';
import { Readable } from 'node:stream';

import crc32 from 'crc-32';
import { filesize } from 'filesize';

/**
 * Utility helper functions for TeraBox API requests
 * @module helper
 */

/**
 * Calculate proper chunk size for upload process
 * @param {integer} fileSize - File size in bytes
 * @param {Boolean} is_vip - VIP user flag
 * @returns {integer} Calculated chunk size
 */
function getChunkSize(fileSize, is_vip = true) {
    const MiB = 1024 * 1024;
    const GiB = 1024 * MiB;
    
    const limitSizes = [4, 8, 16, 32, 64, 128];
    
    if(!is_vip){
        return limitSizes.at(0) * MiB;
    }
    
    for (const limit of limitSizes) {
        if (fileSize &lt;= limit * GiB) {
            return limit * MiB;
        }
    }
    
    return limitSizes.at(-1) * MiB;
}

/**
 * Calculate hashes for specific local file
 * @param {string} filePath - Path to local file
 * @returns {Object} Calculated hashes for specific local file
 */
async function hashFile(filePath) {
    const stat = fs.statSync(filePath);
    const sliceSize = 256 * 1024;
    const splitSize = getChunkSize(stat.size);
    const hashedData = newProgressData();
    
    let crcHash = 0;
    const fileHash = crypto.createHash('md5');
    const sliceHash = crypto.createHash('md5');
    let chunkHash = crypto.createHash('md5');
    
    const hashData = {
        crc32: 0,
        slice: '',
        file: '',
        etag: '',
        chunks: []
    };
    
    let bytesRead = 0;
    let allBytesRead = 0;
    
    const stream = fs.createReadStream(filePath);
    
    try {
        for await (const data of stream) {
            fileHash.update(data);
            
            crcHash = crc32.buf(data, crcHash);
            
            let offset = 0;
            while (offset &lt; data.length) {
                const remaining = data.length - offset;
                
                const sliceRemaining = sliceSize - allBytesRead;
                const chunkRemaining = splitSize - bytesRead;
                
                const sliceAllowed = allBytesRead &lt; sliceSize;
                const readLimit = sliceAllowed
                    ? Math.min(remaining, chunkRemaining, sliceRemaining)
                    : Math.min(remaining, chunkRemaining);
                
                const chunk = data.subarray(offset, offset + readLimit);
                chunkHash.update(chunk);
                
                if (sliceAllowed) {
                    sliceHash.update(chunk);
                }
                
                offset += readLimit;
                allBytesRead += readLimit;
                bytesRead += readLimit;
                
                if (bytesRead >= splitSize) {
                    hashData.chunks.push(chunkHash.digest('hex'));
                    chunkHash = crypto.createHash('md5');
                    bytesRead = 0;
                }
            }
            
            hashedData.all = hashedData.parts[0] = allBytesRead;
            printProgressLog('Hashing', hashedData, stat.size);
        }
        
        if (bytesRead > 0) {
            hashData.chunks.push(chunkHash.digest('hex'));
        }
        
        hashData.crc32 = crcHash >>> 0;
        hashData.slice = sliceHash.digest('hex');
        hashData.file = fileHash.digest('hex');
        hashData.etag = hashData.file;
        
        if(hashData.chunks.length > 1){
            const chunksJSON = JSON.stringify(hashData.chunks);
            const chunksEtag = crypto.createHash('md5').update(chunksJSON).digest('hex');
            hashData.etag = `${chunksEtag}-${hashData.chunks.length}`;
        }
        
        console.log();
        return hashData;
    }
    catch (error) {
        console.log();
        throw error;
    }
}

async function runWithConcurrencyLimit(data, tasks, limit) {
    let index = 0;
    let failed = false;
    
    const runTask = async () => {
        while (index &lt; tasks.length &amp;&amp; !failed) {
            const currentIndex = index++;
            await tasks[currentIndex]();
        }
    };
    
    const workers = Array.from({ length: limit }, () => runTask());
    
    try{
        await Promise.all(workers);
    }
    catch(error){
        console.error('\n[ERROR]', unwrapErrorMessage(error));
        failed = true;
    }
    
    return {ok: !failed, data: data};
};

function printProgressLog(prepText, sentData, fsize){
    readline.cursorTo(process.stdout, 0, null);
    
    const uploadedBytesSum = Object.values(sentData.parts).reduce((acc, value) => acc + value, 0);
    const uploadedBytesStr = filesize(uploadedBytesSum, {standard: 'iec', round: 3, pad: true, separator: '.'});
    const filesizeBytesStr = filesize(fsize, {standard: 'iec', round: 3, pad: true});
    const uploadedBytesFStr = `(${uploadedBytesStr}/${filesizeBytesStr})`;
    
    const uploadSpeed = sentData.all * 1000 / (Date.now() - sentData.start) || 0;
    const uploadSpeedStr = filesize(uploadSpeed, {standard: 'si', round: 2, pad: true, separator: '.'}) + '/s';
    
    const remainingTimeInt = Math.max((fsize - uploadedBytesSum) / uploadSpeed, 0);
    const remainingTimeSec = remainingTimeInt > 99*3636+35 ? 99*3636+35 : remainingTimeInt;
    const remainingSeconds = Math.floor(remainingTimeSec % 60);
    const remainingMinutes = Math.floor((remainingTimeSec % 3600) / 60);
    const remainingHours = Math.floor(remainingTimeSec / 3600);
    const [remH, remM, remS] = [remainingHours, remainingMinutes, remainingSeconds].map(t => String(t).padStart(2, '0'));
    const remainingTimeStr = `${remH}h${remM}m${remS}s left...`;
    
    const percentage = Math.floor((uploadedBytesSum / fsize) * 100);
    const percentageFStr = `${percentage}% ${uploadedBytesFStr}`;
    const uploadStatusArr = [percentageFStr, uploadSpeedStr, remainingTimeStr];
    process.stdout.write(`${prepText}: ${uploadStatusArr.join(', ')}`);
    readline.clearLine(process.stdout, 1);
}

function md5MismatchText(hash1, hash2, partnum, total){
    return [
        `MD5 hash mismatch for file (part: ${partnum} of ${total})`,
        `[Actual MD5:${hash1} / Got MD5:${hash2}]`,
    ];
}

async function uploadChunkTask(app, data, file, partSeq, uploadData, externalAbort) {
    const splitSize = getChunkSize(data.size);
    const start = partSeq * splitSize;
    const end = Math.min(start + splitSize, data.size) - 1;
    const maxTries = uploadData.maxTries;
    
    const uploadLog = (chunkSize) => {
        uploadData.all += chunkSize;
        uploadData.parts[partSeq] += chunkSize;
        printProgressLog('Uploading', uploadData, data.size);
    }
    
    const blob_size = end + 1 - start;
    const buffer = Buffer.alloc(blob_size);
    await file.read(buffer, 0, blob_size, start);
    const blob = new Blob([buffer], { type: 'application/octet-stream' });
    let is_ok = false;
    
    for (let i = 0; i &lt; maxTries; i++) {
        if (externalAbort.aborted) {
            break;
        }
        
        try{
            const res = await app.uploadChunk(data, partSeq, blob, null, externalAbort);
            const chunkMd5 = data.hash.chunks[partSeq];
            
            // check if we have chunks hash
            if (app.CheckMd5Val(chunkMd5) &amp;&amp; res.md5 !== chunkMd5){
                const md5Err = md5MismatchText(chunkMd5, res.md5, partSeq+1, data.hash.chunks.length)
                throw new Error(md5Err.join('\n\t'));
            }
            
            // check if we don't have chunk hash and data.hash_check not set to false
            const skipChunkHashCheck = typeof data.hash_check === 'boolean' &amp;&amp; data.hash_check === false;
            if(!app.CheckMd5Val(chunkMd5) &amp;&amp; !skipChunkHashCheck){
                const calcChunkMd5 = crypto.createHash('md5').update(buffer).digest('hex');
                if(calcChunkMd5 !== res.md5){
                    const md5Err = md5MismatchText(calcChunkMd5, res.md5, partSeq+1, data.hash.chunks.length)
                    throw new Error(md5Err.join('\n\t'));
                }
            }
            
            // update chunkMd5 to res.md5
            if(app.CheckMd5Val(res.md5) &amp;&amp; chunkMd5 !== res.md5){
                data.hash.chunks[partSeq] = res.md5;
            }
            
            // log uploaded
            data.uploaded[partSeq] = true;
            uploadLog(blob_size);
            is_ok = true;
            
            break;
        }
        catch(error){
            if (externalAbort.aborted) {
                break;
            }
            
            readline.clearLine(process.stdout, 0);
            readline.cursorTo(process.stdout, 0, null);
            
            let message = error.message;
            if(error.cause){
                message += ' Cause';
                if(error.cause.errno){
                    message += ' #' + error.cause.errno;
                }
                if(error.cause.code){
                    message += ' ' + error.cause.code;
                }
            }
            
            const uplFailedMsg1 = ' -> Upload failed for part #' + (partSeq+1);
            const uplFailedMsg2 = `: ${message}`;
            const doRetry = i+1 != maxTries ? `, retry #${i+1}` : '';
            
            process.stdout.write(uplFailedMsg1 + uplFailedMsg2 + doRetry + '...\n');
            uploadLog(0);
        }
    }
    
    if(!is_ok){
        throw new Error(`Upload failed! [PART #${partSeq+1}]`);
    }
}

function newProgressData() {
    return {
        all: 0,
        start: Date.now(),
        parts: {},
    }
}

/**
 * Helper function for uploading chunks to TeraBox
 * @param {TeraBoxApp} app - File size in bytes
 * @param {Object} data - Upload data parameters
 * @param {integer} maxTasks - maximum task for uploading
 * @param {integer} maxTries - maximum tries for chunk uploading
 * @returns {Object} Upload data parameters and status
 */
async function uploadChunks(app, data, filePath, maxTasks = 10, maxTries = 5) {
    const splitSize = getChunkSize(data.size);
    const totalChunks = data.hash.chunks.length;
    const lastChunkSize = data.size - splitSize * (data.hash.chunks.length - 1);
    
    const tasks = [];
    const uploadData = newProgressData();
    const externalAbortController = new AbortController();
    uploadData.maxTries = maxTries;
    
    if(data.uploaded.filter(pStatus => pStatus == false).length > 0){
        for (let partSeq = 0; partSeq &lt; totalChunks; partSeq++) {
            uploadData.parts[partSeq] = 0;
            if(data.uploaded[partSeq]){
                const chunkSize = partSeq &lt; totalChunks - 1 ? splitSize : lastChunkSize;
                uploadData.parts[partSeq] = splitSize;
            }
        }
        
        const file = await fs.promises.open(filePath, 'r');
        for (let partSeq = 0; partSeq &lt; totalChunks; partSeq++) {
            if(!data.uploaded[partSeq]){
                tasks.push(() => {
                    return uploadChunkTask(app, data, file, partSeq, uploadData, externalAbortController.signal);
                });
            }
        }
        
        printProgressLog('Uploading', uploadData, data.size);
        const cMaxTasks = totalChunks > maxTasks ? maxTasks : totalChunks;
        const upload_status = await runWithConcurrencyLimit(data, tasks, cMaxTasks);
        
        console.log();
        externalAbortController.abort();
        await file.close();
        
        return upload_status;
    }
    
    return {ok: true, data};
}

/**
 * Helper function unwraping Error Message
 * @param {Object} err - Error object
 * @returns {Object} Error data
 */
function unwrapErrorMessage(err) {
    if (!err) {
        return;
    }
    
    let e = err;
    let res = err.message;
    while (e.cause) {
        e = e.cause;
        if (e.message) {
            res += ': ' + e.message;
        }
    }
    
    return res;
}

export {
    getChunkSize,
    hashFile,
    uploadChunks,
    unwrapErrorMessage,
};
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.4</a> using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
